{"version":3,"sources":["polyfills.ts","util.ts","hash.ts","settings.ts","knob.ts","stores.ts","drawer.ts","index.ts"],"names":[],"mappings":"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","file":"index.js","sourceRoot":"../src","sourcesContent":["export default function polyfill() {\n    /**\n     * Object.assign()\n     */\n    if (typeof Object.assign !== 'function') {\n        // Must be writable: true, enumerable: false, configurable: true\n        Object.defineProperty(Object, \"assign\", {\n            value: function assign(target, varArgs) { // .length of function is 2\n                'use strict';\n                if (target === null || target === undefined) {\n                    throw new TypeError('Cannot convert undefined or null to object');\n                }\n\n                var to = Object(target);\n\n                for (var index = 1; index < arguments.length; index++) {\n                    var nextSource = arguments[index];\n\n                    if (nextSource !== null && nextSource !== undefined) {\n                        for (var nextKey in nextSource) {\n                            // Avoid bugs when hasOwnProperty is shadowed\n                            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\n                                to[nextKey] = nextSource[nextKey];\n                            }\n                        }\n                    }\n                }\n                return to;\n            },\n            writable: true,\n            configurable: true\n        });\n    }\n\n    /**\n     * CustomEvent() constructor\n     */\n    (function () {\n\n        if ( typeof window.CustomEvent === \"function\" ) return false;\n\n        function CustomEvent ( event, params ) {\n            params = params || { bubbles: false, cancelable: false, detail: null };\n            var evt = document.createEvent( 'CustomEvent' );\n            evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );\n            return evt;\n        }\n\n        // @ts-ignore\n        window.CustomEvent = CustomEvent;\n    })();\n}\n","/**\n * Is this an element?\n * @param el\n * @returns {boolean}\n */\nimport {ISettings} from \"./types\";\n\nconst isEl = (el: any): boolean => (el instanceof Element) || (el instanceof HTMLDocument);\n\nconst tagRegex = /^\\w*.$/;\nconst idRegex = /^#[\\w_-]*.$/;\nconst classRegex = /^\\.[\\w_-]*.$/;\n\n/**\n * Get an array of elements matching a string, or return an element passed.\n * @param el\n * @returns {HTMLElement[]}\n */\nconst sel = (el: any): Array<HTMLElement> => {\n    // Return immediately, but in an array\n    if (isEl(el)) return [el];\n    // Not an arg we understand\n    if (typeof el !== `string`) return [];\n    // Tag argument, use faster search\n    if (tagRegex.test(el)) return Array.prototype.slice.call(document.getElementsByTagName(el));\n    // ID argument, use faster search\n    if (idRegex.test(el)) return [document.getElementById(el.slice(1))];\n    // Class argument, use faster search\n    if (classRegex.test(el)) return Array.prototype.slice.call(document.getElementsByClassName(el.slice(1)));\n    // Just use querySelectorAll\n    return Array.prototype.slice.call(document.querySelectorAll(el));\n};\n\n/**\n * Replicates .flat() for arrays with only a single level of depth.\n *\n * This is to handle browsers (i.e. IE) that don't support .flat().\n * @param arr\n * @return {any[]}\n */\nconst flattenSingle = (arr: Array<any>): Array<any> => arr.reduce((acc, val) => acc.concat(val), []);\n\n/**\n * Attempts to make something (usually a string) in a url-safe string.\n *\n * @param string\n * @return string\n */\nconst urlify = (string: any): string => string\n    .toString()\n    .toLowerCase()\n    .replace(/\\s+/g, '-')\n    .replace(/[^\\w-]+/g, '')\n    .replace(/--+/g, '-')\n    .replace(/^-+/, '')\n    .replace(/-+$/, '');\n\n/**\n * Generate a pretty unique ID.\n *\n * *IMPORTANT*\n *\n * This is intended to be pretty random, and fairly cryptographically\n * secure, but if you really need that I'd recommend importing a package\n * and using that; This is just a simple implementation so I can avoid\n * a dependency.\n *\n * @link https://stackoverflow.com/a/2117523\n * @returns {string}\n */\nfunction uuid(): string {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n        var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);\n        return v.toString(16);\n    });\n}\n\n/**\n * Bind to drawers/knobs and use to resolve passed and read arguments.\n * @param user\n * @param collected\n * @param settings\n * @param stores\n */\nfunction resolveLoadArguments(\n    user: ISettings.Default,\n    collected: Map<string, any>,\n    settings: Array<string>,\n    stores: Array<string>,\n): void {\n    if (typeof user === 'object') {\n        Object.keys(user).map((key: string) => {\n            // Skip args that have already been set\n            if (!collected.has(key)) {\n                if (settings.indexOf(key) > -1\n                    || stores.indexOf(key) > -1) {\n                    collected.set(key, user[key]);\n                }\n            }\n        })\n    }\n\n    if (collected.size > 0) {\n        collected.forEach((value: any, key: string) => {\n            /**\n             * This assumes there will be no overlap, and if there is, then\n             * settings will take precedence.\n             */\n            if (settings.indexOf(key) > -1) {\n                this.settings[key] = value;\n            } else if (stores.indexOf(key) > -1) {\n                this.store[key] = value;\n            }\n        });\n    }\n}\n\n/**\n * Bound to stores and settings objects to return their defaults.\n */\nfunction getDefaults(): Map<string, any> {\n    const defaults = new Map();\n    Object.keys(this).map(key => {\n        defaults.set(key, this[key]);\n    });\n    return defaults;\n}\n\nexport {isEl, sel, flattenSingle, urlify, uuid, getDefaults, resolveLoadArguments}\n","function setHash(hash: string): void {\n    history.pushState(null, null, `#${hash}`);\n}\n\n/**\n * Get the current hash string.\n */\nfunction extractHash(): string {\n    return window.location.hash.slice(1);\n}\n\n/**\n * Removes hash, if it matches hash on this Drawer.\n * @param hash string\n */\nfunction clearHash(hash: string): void {\n    if (hash && extractHash() === hash) {\n        wipeHash();\n    }\n}\n\n/**\n * Removes *any* existing hash.\n */\nfunction wipeHash() {\n    history.pushState(null, null, window.location.pathname);\n}\n\n/**\n * Is this a valid hash or not?\n * @param test\n */\nfunction isValidHash(test: any): boolean {\n    return (typeof test === 'string') && test.length > 0;\n}\n\n/**\n * If test is a valid hash, then run the call back with test as an argument.\n * @param test\n * @param callback\n */\nfunction ifValidHash(test: any, callback: Function) {\n   if (isValidHash(test)) {\n       callback(test);\n   }\n}\n\nexport {setHash, extractHash, clearHash, wipeHash, isValidHash, ifValidHash}\n","import {isValidHash} from \"./hash\";\nimport {getDefaults, urlify, uuid} from \"./util\";\n\nfunction setUpSettings(settings) {\n    Object.defineProperties(settings, {\n        repo: {\n            value: new Map(),\n            writable: true,\n        },\n        append: {\n            value: append.bind(settings),\n        },\n    });\n}\n\n/**\n * This will append items to a settings item that is an array.\n *\n * Bind it to your settings object and you're off to the races.\n * @param name\n * @param row\n */\nfunction append(name: string, row: any) {\n    if (!this.repo.has(name)) {\n        this.repo.set(name, [row]);\n    } else {\n        let current = this.repo.get(name);\n        current.push(row);\n        this.repo.set(name, current);\n    }\n}\n\nfunction DrawerSettings() {\n    setUpSettings(this);\n\n    Object.defineProperties(this, {\n        inStates: {\n            value: (state: string): boolean => this.states.indexOf(state) > -1,\n        },\n        /**\n         * This is a list of states the drawer can have. The names of the terms have\n         * no internal meaning: They will be used to populated `data-state` and will\n         * be matched against by `hiddenStates`, but they're essentially arbitrary.\n         *\n         * `cycle()` will move from the current state to the next state in this list,\n         * and then start again from the first item when it reaches the end.\n         */\n        states: {\n            enumerable: true,\n            get: () => this.repo.get('states') || [`open`, `closed`],\n            set: (arg: string | Array<string>) => {\n                if (typeof arg === 'string') {\n                    append('states', arg);\n                } else if (Array.isArray(arg)) {\n                    this.repo.set('states', arg);\n                }\n            }\n        },\n        /**\n         * This is the state that the drawer should start in. If it's not set,\n         * it'll default to the first state described in `states`.\n         */\n        initState: {\n            enumerable: true,\n            get: () => this.repo.get('initState') || this.states[0],\n            set: (arg: string) => {\n                if (typeof arg === 'string' && this.inStates(arg)) {\n                    this.repo.set('initState', arg);\n                } else {\n                    this.repo.set('initState', false);\n                }\n            }\n        },\n        /**\n         * These are states from the `states` array that are considered \"closed\".\n         * Without other configuration, this means that when the drawer enters one\n         * of these states, it will receive the `hidden` attribute, and ann attached\n         * knobs will get `aria-expanded=\"false\"`.\n         *\n         * To disable this behavior, just make this an empty array.\n         */\n        hiddenStates: {\n            enumerable: true,\n            get: () => this.repo.get('hiddenStates') || [`closed`],\n            set: (arg: string | Array<string>) => {\n                if (typeof arg === 'string' && this.inStates(arg)) {\n                    append('hiddenStates', arg);\n                } else if (Array.isArray(arg)) {\n                    const validHiddenStates = arg.filter(state => this.inStates(state));\n                    this.repo.set('hiddenStates', validHiddenStates);\n                }\n            }\n        },\n        /**\n         * The hash will be appended to the URL when the Drawer is in the state\n         * described in hashState. If hash is not a string with a length greater\n         * than one, all hash functionality is disabled. If hash is valid, but\n         * hashState is not, then the de facto hash-state will be the first non-\n         * hidden state found in states.\n         */\n        hash: {\n            enumerable: true,\n            get: () => this.repo.get('hash') || '',\n            set: (arg: string) => {\n                if (isValidHash(arg)) {\n                    this.repo.set('hash', urlify(arg));\n                }\n            }\n        },\n        /**\n         * When this state is active on the drawer, the hash will be added to the\n         * url, and this state will be activated if the hash is in the URL. If\n         * this is set but hash is not valid, nothing will happen.\n         */\n        hashState: {\n            enumerable: true,\n            get: () => {\n                if (!this.repo.get('hashState')) {\n                    const nonHiddenStates = this.states\n                        .filter(x => this.hiddenStates.indexOf(x) < 0);\n                    return nonHiddenStates[0] || '';\n                }\n                return this.repo.get('hashState');\n            },\n            set: (arg: string) => {\n                if (typeof arg === 'string' && this.inStates(arg) && this.repo.get('hiddenState').indexOf(arg) < 0) {\n                    this.repo.set('hashState', arg);\n                }\n            }\n        },\n        /**\n         * If you need better uuids, pass a callback to this function that\n         * generates them.\n         */\n        uuid: {\n            enumerable: true,\n            get: () => this.repo.get('uuid') || uuid,\n            set: (arg: Function) => {\n                this.repo.set('uuid', arg);\n            }\n        },\n    });\n\n    // Now set up defaults\n    Object.defineProperty(this, 'defaults', {\n        value: getDefaults.bind(this)(),\n    });\n}\n\nfunction KnobSettings() {\n    setUpSettings(this);\n\n    Object.defineProperties(this, {\n        /**\n         * When true, clicking this knob will cycle all attached drawers.\n         */\n        cycle: {\n            enumerable: true,\n            get: () => this.repo.get('cycle') || true,\n            set: (arg) => this.repo.set(`cycle`, Boolean(arg)),\n        },\n        /**\n         * When true, this will enable all knob-related accessiblity featured,\n         * mainly aria attributes.\n         */\n        accessibility: {\n            enumerable: true,\n            get: () => this.repo.get('actions') || true,\n            set: (arg) => this.repo.set('actions', Boolean(arg))\n        },\n    });\n\n    // Now set up defaults\n    Object.defineProperty(this, 'defaults', {\n        value: getDefaults.bind(this)(),\n    });\n\n}\n\nexport {DrawerSettings, KnobSettings}\n","import {resolveLoadArguments} from \"./util\";\nimport {IKnob, IDrawer, IActions} from \"./types\";\nimport {KnobSettings} from \"./settings\";\nimport {KnobStore} from \"./stores\";\nimport {getDrawer} from \"./drawer\";\n\n\n/**\n * Create a new knob on an element.\n *\n * ** WARNING **\n * This will not check to see if a Knob already exists on this element; you are\n * advised to check before instantiating a new knob, i.e. with getKnob().\n * Otherwise you will likely get undesirable behavior.\n *\n * @param el\n * @param userArguments\n * @constructor\n */\nfunction Knob(el: HTMLElement, userArguments?: IKnob.Settings | object | undefined) {\n    Object.defineProperties(this, {\n        settings: {\n            value: new KnobSettings(),\n            writable:true,\n        },\n        store: {\n            value: new KnobStore(),\n            writable: true,\n        },\n        mount: {\n            get: (): IKnob.Element => this.store.mount,\n            set: (element) => this.store.mount = element,\n        },\n        actions: {\n            get: () => this.store.actions,\n            set: (action: IActions.Observe) => this.store.actions = action\n        },\n        drawers: {\n            get: (): Map<IDrawer.Element, MutationObserver> => this.store.drawers,\n            set: (drawers: string | HTMLElement | Array<HTMLElement | string>) => this.store.drawers = drawers,\n        },\n        detachDrawer: {\n            value: (drawer: IDrawer.Element) => {\n                const event = new CustomEvent('knob.drawerRemoved', {\n                    detail: {\n                        drawer: drawer,\n                        knob: this.mount,\n                    },\n                });\n                this.mount.dispatchEvent(event);\n                drawer.dispatchEvent(event);\n            },\n        }\n    });\n\n    // Attach API\n    this.mount = el;\n    this.mount.knob = this;\n\n    this.actions = handleAriaExpandedState;\n\n    this.mount.addEventListener(`knob.drawerAdded`, handleDrawerAddedEvent.bind(this));\n    this.mount.addEventListener(`knob.drawerRemoved`, handleRemovalEvent.bind(this));\n    this.mount.addEventListener(`drawer.knobRemoved`, handleRemovalEvent.bind(this));\n    this.mount.addEventListener(`click`, handleClick.bind(this));\n\n    loadUserArguments.bind(this)(userArguments);\n}\n\n/**\n * Get the knob on an element.\n * @param el\n */\nfunction getKnob(el: HTMLElement | IKnob.Element): IKnob.API | undefined {\n    if (`knob` in el) {\n        return el.knob;\n    }\n    return undefined;\n}\n\n/**\n * Actions to be executed when a drawer is added to this Knob.\n * @param event\n */\nfunction handleDrawerAddedEvent(event: IKnob.Event) {\n    const {drawer: api} = event.detail.drawer;\n\n    setAriaExpanded(this, api);\n    setAriaControls(this, api);\n}\n\n/**\n * Actions to be executed when a drawer is removed from this Knob.\n * @param event\n */\nfunction handleRemovalEvent(event: IKnob.Event) {\n    const {detail: {drawer}, type} = event;\n    switch (type) {\n        case 'knob.drawerRemoved':\n        case 'drawer.knobRemoved':\n            if (this.drawers.has(drawer)) {\n                // Turn off observation\n                this.drawers.get(drawer).disconnect();\n\n                // Remove Drawer\n                this.store.repo.get('drawers').delete(drawer);\n            }\n            break;\n    }\n}\n\n/**\n * Handle changing aria-expanded when the attached drawer is hidden\n * (or not).\n * @param list\n * @param api\n */\nfunction handleAriaExpandedState(list: Array<MutationRecord>, api: IKnob.API) {\n    for (let i = 0; i < list.length; i++) {\n        const {attributeName, target} = list[i];\n        if (`hidden` === attributeName) {\n            setAriaExpanded(api, getDrawer((target as HTMLElement)));\n        }\n    }\n}\n\n/**\n * Handles setting the aria-expanded attribute on the knob.\n * @param api\n * @param drawer\n */\nfunction setAriaExpanded(api: IKnob.API, drawer: IDrawer.API) {\n    if (api.settings.accessibility) {\n        api.mount.setAttribute(`aria-expanded`, String(!drawer.hidden));\n    }\n}\n\n/**\n * Handles setting up the aria-controls attribute on the knob.\n * @param api\n * @param drawer\n */\nfunction setAriaControls(api: IKnob.API, drawer: IDrawer.API) {\n    if (api.settings.accessibility) {\n        api.mount.setAttribute(`aria-controls`, drawer.mount.id);\n    }\n}\n\n/**\n * Fired when the knob registers a click event.\n *\n * Only fires if `doCycle` is true. `doCycle` gets its\n * initial value from `knobsCycle` in the settings, but\n * can be independently set per knob (manually).\n */\nfunction handleClick() {\n    const {settings: {cycle}, drawers} = this;\n    if (cycle) {\n        drawers.forEach((observer: MutationObserver, drawer: IDrawer.Element) => {\n            getDrawer(drawer)?.cycle();\n        });\n    }\n}\n\n/**\n * Handle loading arguments passed directly, and described on the element.\n * @param userArguments\n */\nfunction loadUserArguments(userArguments: IKnob.Settings) {\n    const allowedSettings = Object.keys(this.settings);\n    const allowedStores = Object.keys(this.store);\n    const collectedArguments = new Map();\n\n    const {dataset} = this.mount;\n    if (dataset.cycle) collectedArguments.set('cycle', dataset.cycle === `true`);\n    if (dataset.accessibility) collectedArguments.set('accessibility', dataset.accessibility === `true`);\n\n    resolveLoadArguments.bind(this)(userArguments, collectedArguments, allowedSettings, allowedStores)\n}\n\nexport {Knob, getKnob}\n","import {flattenSingle, getDefaults, isEl, sel, uuid} from \"./util\";\nimport {getKnob, Knob} from \"./knob\";\nimport {IActions, IDrawer, IKnob} from \"./types\";\nimport {getDrawer} from \"./drawer\";\n\nfunction getImmutableMap(key: string, fallback?: Iterable<any>) {\n    if (undefined === fallback) {\n        fallback = [];\n    }\n    return new Map(this.repo.get(key) || fallback);\n}\n\nfunction getImmutableArray(key: string, fallback: Array<any>) {\n    if (undefined === fallback) {\n        fallback = [];\n    }\n    const array = this.repo.get(key) || fallback;\n    return [...array];\n}\n\n/**\n * Set up a basic store.\n * @param store\n */\nfunction setUpStore(store): void {\n    Object.defineProperties(store, {\n        repo: {\n            value: new Map(),\n            writable: true,\n        },\n        mapGet: {\n            value: getImmutableMap.bind(store),\n        },\n        arrayGet: {\n            value: getImmutableArray.bind(store),\n        },\n        mount: {\n            enumerable: true,\n            get: () => store.repo.get('mount') || undefined,\n            set: (element) => {\n                // Can only be mounted once\n                if (!isEl(store.repo.get('mount')) && isEl(element)) {\n                    store.repo.set('mount', element);\n                }\n            }\n        },\n        actions: {\n            enumerable: true,\n            get: () => store.mapGet('actions'),\n            set: (action: IActions.Observe) => {\n                // \"lazy\"-initialization\n                if (store.actions.size < 1) {\n                    store.repo.set('actions', store.actions);\n                }\n\n                let actions;\n                if (Array.isArray(action)) {\n                    actions = action.map(flattenSingle);\n                } else {\n                    actions = [action];\n                }\n\n                actions\n                    .map((action) => store.repo.get('actions')\n                        .set((action.name || uuid()), action));\n            }\n        },\n    });\n}\n\nfunction DrawerStore() {\n    setUpStore(this);\n\n    Object.defineProperties(this, {\n        knobs: {\n            enumerable: true,\n            get: (): Map<IKnob.Element, IKnob.API> => this.mapGet('knobs'),\n            set: (arg: Array<string | HTMLElement> | string | HTMLElement | IDrawer.KnobSetup) => {\n                if (this.knobs.size < 1) {\n                    this.repo.set('knobs', this.knobs);\n                }\n                let knobs;\n                let settings = {};\n                if (Array.isArray(arg)) {\n                    knobs = flattenSingle(arg.map(sel));\n                } else if (arg.hasOwnProperty('elements')\n                    && arg.hasOwnProperty('settings')) {\n                    /**\n                     * This allows for passing knob settings by passing an object with\n                     * the following shape:\n                     * {\n                     *     elements: ['selector', elementObject],\n                     *     settings: {\n                     *         cycle: true,\n                     *         accessibility: false,\n                     *         ...\n                     *     }\n                     * }\n                     */\n                    knobs = flattenSingle((arg as IDrawer.KnobSetup).elements.map(sel));\n                    settings = (arg as IDrawer.KnobSetup).settings;\n                } else {\n                    knobs = sel(arg);\n                }\n                knobs.map((knob: HTMLElement) => {\n                    // Settings are only applied if this is a new Knob.\n                    const api = getKnob(knob) || new Knob(knob, settings);\n                    api.drawers = this.mount; // Knob will take care of the rest\n                });\n            }\n        },\n    });\n\n    // Now set up defaults\n    Object.defineProperty(this, 'defaults', {\n        value: getDefaults.bind(this)(),\n    });\n}\n\nfunction KnobStore() {\n    setUpStore(this);\n\n    Object.defineProperties(this, {\n        drawers: {\n            enumerable: true,\n            get: () => this.mapGet('drawers'),\n            set: (drawer: string | Array<string> | HTMLElement) => {\n                // \"lazy\"-initialization\n                if (this.drawers.size < 1) {\n                    this.repo.set('drawers', this.drawers)\n                }\n\n                let drawers;\n                if (Array.isArray(drawer)) {\n                    drawers = drawer.map(sel).map(flattenSingle);\n                } else {\n                    drawers = sel(drawer);\n                }\n\n                drawers\n                    .filter((drawer: HTMLElement): drawer is IDrawer.Element  => {\n                        return getDrawer(drawer) !== undefined\n                    })\n                    .map((drawer: IDrawer.Element) => {\n                        // Create observer\n                        const observer = new MutationObserver((list, observer) => {\n                            if (this.repo.get('actions').size > 0) {\n                                this.repo.get('actions').forEach((action) => {\n                                    action(list, this.repo.get('mount').knob, observer);\n                                })\n                            }\n                        });\n\n                        // Start observer\n                        observer.observe(drawer, {\n                            attributes: true,\n                            attributeFilter: [`data-states`, `hidden`],\n                            attributeOldValue: true,\n                            childList: false,\n                            subtree: false,\n                        });\n\n                        // Store drawer and observer\n                        this.repo.get('drawers').set(drawer, observer);\n\n                        // Tell the Drawer that this Knob is attached\n                        drawer.drawer.store.repo.get('knobs')\n                            .set(this.repo.get('mount'), this.repo.get('mount').knob);\n\n                        // Tell the knob we've added a drawer\n                        this.repo.get('mount').dispatchEvent(\n                            new CustomEvent('knob.drawerAdded', {\n                                detail: {\n                                    drawer: drawer,\n                                }\n                            }));\n\n                    });\n            },\n        },\n    });\n\n    // Now set up defaults\n    Object.defineProperty(this, 'defaults', {\n        value: getDefaults.bind(this)(),\n    });\n}\n\nexport {KnobStore, DrawerStore}\n","import {resolveLoadArguments, uuid} from \"./util\";\nimport {DrawerSettings, KnobSettings} from \"./settings\";\nimport {IActions, IDrawer, IKnob} from \"./types\";\nimport {clearHash, extractHash, ifValidHash, isValidHash, setHash, wipeHash} from \"./hash\";\nimport {DrawerStore, KnobStore} from \"./stores\";\n\n/**\n * Activate a drawer.\n * @param el\n * @param userArguments\n */\nfunction Drawer(el: HTMLElement, userArguments?: IDrawer.Settings | object | undefined) {\n    Object.defineProperties(this, {\n        settings: {\n            value: new DrawerSettings(),\n            writable:true,\n        },\n        store: {\n            value: new DrawerStore(),\n            writable: true,\n        },\n        mount: {\n            get: () => this.store.mount,\n            set: (mount: IDrawer.Element) => this.store.mount = mount,\n        },\n        state: {\n            get: (): string => this.mount.dataset.state,\n            set: (state: string) => {\n                if (this.settings.states.indexOf(state) > -1) {\n                    this.mount.dataset.state = state;\n                }\n            },\n        },\n        hidden: {\n            get: (): boolean => this.mount.hidden,\n            set: (hide: boolean) => this.mount.hidden = Boolean(hide),\n        },\n        hash: {\n            get: (): string => this.settings.hash,\n            set: (hash: string) => this.settings.hash = hash,\n        },\n        actions: {\n            get: (): Map<string, IActions.Observe> => this.store.actions,\n            set: (action: IActions.Observe) => this.store.actions = action,\n        },\n        knobs: {\n            get: (): Map<IKnob.Element, IKnob.API> => this.store.knobs,\n            set: (knob: string | HTMLElement | Array<HTMLElement | string>) => this.store.knobs = knob\n        },\n        hasher: {\n            value: {\n                setUrl: () => ifValidHash(this.settings.hash, setHash),\n                clearUrl: () => ifValidHash(this.settings.hash, clearHash),\n                wipeUrl: wipeHash\n            },\n        },\n        cycle: {\n            value: (states: Array<string>) => cycle(this.mount, states),\n        },\n        detachKnob: {\n            value: (knob: IKnob.Element) => {\n                if (this.knobs.has(knob)) {\n                    const event = new CustomEvent('drawer.knobRemoved', {\n                        detail: {\n                            drawer: this.mount,\n                            knob: knob,\n                        },\n                    });\n                    this.mount.dispatchEvent(event);\n                    knob.dispatchEvent(event);\n                }\n            }\n        }\n    });\n\n    /** ==== Set up actions ==== */\n    // Couple state to hidden attribute\n    this.actions = hiddenCallback;\n\n    // Set up hash actions\n    this.actions = hashCallback;\n\n    // Attach the API to the element\n    this.mount = el;\n    this.mount.drawer = this;\n\n    // Ensure id\n    if (!this.mount.id) {\n        this.mount.id = this.settings.uuid ? this.settings.uuid() : uuid();\n    }\n\n    this.mount.addEventListener(`knob.drawerRemoved`, handleRemovalEvent.bind(this));\n    this.mount.addEventListener(`drawer.knobRemoved`, handleRemovalEvent.bind(this));\n\n    const watcher = new MutationObserver((list: Array<MutationRecord>, observer: MutationObserver) => handleMutation.bind(this)(list, observer));\n    this.observer = watcher.observe(this.mount, {\n        attributes: true,\n        attributeFilter: [`data-state`, `hidden`],\n        attributeOldValue: true,\n        childList: false,\n        subtree: false,\n    });\n\n    loadUserArguments.bind(this)(userArguments);\n\n    // If there's a matching hash, set the hashState as the initState\n    if (extractHash().length > 0) {\n        const hash = extractHash();\n        if (isValidHash(hash) && this.getHash() === hash && this.getHashState().length > 0) {\n            this.settings.initState = this.getHashState();\n        }\n    }\n\n    // Kick things off by setting the initial state\n    this.state = this.settings.initState;\n}\n\n/**\n * Get the API if it exists.\n * Also useful for determining if an element has a drawer attached or not.\n * @param el\n */\nfunction getDrawer(el: HTMLElement | IDrawer.Element): IDrawer.API | undefined {\n    if (`drawer` in el) {\n        return el.drawer;\n    } else {\n        return undefined;\n    }\n}\n\n/**\n * Run actions when the element mutates.\n *\n * @param list\n * @param observer\n */\nfunction handleMutation(list: Array<MutationRecord>, observer: MutationObserver) {\n    this.actions.forEach((action: IActions.Observe) => action(list, this, observer));\n}\n\n/**\n * Handle removes of Knobs and Drawers from either type of element.\n * @param event\n */\nfunction handleRemovalEvent(event: IDrawer.Event) {\n    const {detail: {knob}, type} = event;\n    switch (type) {\n        case 'knob.drawerRemoved':\n        case 'drawer.knobRemoved':\n            if (this.knobs.get(knob)) {\n                // Remove knob\n                this.store.repo.get('knobs').delete(knob);\n            }\n            break;\n    }\n}\n\n/**\n * Set up hidden behavior.\n * @param list\n * @param api\n */\nfunction hiddenCallback(list: Array<MutationRecord>, api: IDrawer.API): void {\n    for (let i = 0; i < list.length; i++) {\n        const {attributeName} = list[i];\n\n        if (`data-state` === attributeName) {\n            api.hidden = api.settings.hiddenStates.indexOf(api.state) > -1;\n        }\n    }\n}\n\n/**\n * Set up hash behavior.\n * @param list\n * @param api\n */\nfunction hashCallback(list: Array<MutationRecord>, api: IDrawer.API): void {\n    for (let i = 0; i < list.length; i++) {\n        const {attributeName} = list[i];\n        const {settings: {hashState}, state, hasher: {setUrl, clearUrl}} = api;\n        if (`data-state` === attributeName) {\n            if (state === hashState) {\n                setUrl();\n            } else {\n                clearUrl();\n            }\n        }\n    }\n}\n\n/**\n * Cycle through all available states, looping around at the end of the array.\n * If it is passed an array of states\n */\nfunction cycle(el: IDrawer.Element, limitedStates?: Array<string>) {\n    const api = getDrawer(el);\n    if (api) {\n        const {settings: {states}} = api;\n        const curIndex = states.indexOf(api.state);\n        let nextState = states[curIndex + 1] || states[0];\n\n        // If states have been passed, cycle only through those\n        if (limitedStates) {\n            const potentialCustomState = limitedStates[limitedStates.indexOf(api.state) + 1] || limitedStates[0];\n            // Only allow valid states\n            if (states.indexOf(potentialCustomState) > -1) {\n                nextState = potentialCustomState;\n            }\n        }\n\n        api.state = nextState;\n    }\n}\n\n/**\n * Handle loading arguments passed directly, and described on the element.\n * @param userArguments\n */\nfunction loadUserArguments(userArguments: IDrawer.Settings) {\n    const allowedSettings = Object.keys(this.settings);\n    const allowedStores = Object.keys(this.store);\n    const collectedArguments = new Map();\n\n    // Handle items described in element HTML\n    const {dataset} = this.mount;\n    if (dataset.state) collectedArguments.set('initState', dataset.state);\n    if (dataset.knob) collectedArguments.set('knobs', dataset.knob);\n    if (dataset.hash) collectedArguments.set('hash', dataset.hash);\n    if (dataset.hashState) collectedArguments.set('hashState', dataset.hashState);\n\n    resolveLoadArguments.bind(this)(userArguments, collectedArguments, allowedSettings, allowedStores);\n}\n\nexport {Drawer, getDrawer, cycle}\n","import polyfill from \"./polyfills\";\nimport {sel} from \"./util\";\nimport {Drawer, getDrawer, cycle} from \"./drawer\";\nimport {Knob, getKnob} from \"./knob\";\nimport {IDrawer} from \"./types\";\n\n// Set up our polyfills before we do anything else\npolyfill();\n\n/**\n * Set up all drawers we can find.\n * @param selector\n * @param userSettings\n */\nfunction Cabinet(selector?: HTMLElement | string, userSettings?: IDrawer.Settings) {\n    const drawers = sel(selector || `[data-module=\"drawer\"]`);\n    if (drawers.length < 1) {\n        return; // There are no drawers\n    }\n\n    return drawers.map((drawer: HTMLElement) => new Drawer(drawer, userSettings));\n}\n\nexport {Cabinet, Drawer, getDrawer, cycle, Knob, getKnob}\n"]}