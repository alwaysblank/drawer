:Date: 07/05/2020
:Author: Ben Martinez-Bateman
:Email: ben@murmurcreative.com
:Version: 2.1.0-alpha
:toc: macro
:toclevels: 3
:toc-title:
:sectanchors:
:sectlinks:
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]
ifndef::env-github[]
:tip-caption: üí°
:note-caption: ‚Ñπ
:important-caption: ‚ùó
:caution-caption: üî•
:warning-caption: ‚ö†
endif::[]

= Drawer

*Broadly:* Open things and close them as well.

*Technically:* Swap states on a particular element.

toc::[]

== Installation

[subs="attributes"]
[source,shell script]
----
npm install @murmurcreative/drawer@{Version}
----

[source,javascript]
----
import {Cabinet} from 'murmur-drawer';
new Cabinet();
----

[source,html]
----
<div data-module="drawer" data-knob="#knob">
    <!--  Drawer Contents  -->
</div>

<button id="knob">Toggle</button>
----

Now you have a Drawer!

For more details on functionality, etc, take a look at the link:#config[configuration] and link:#api[API] sections.

[#config]
== Configuration

Both `Drawer` and `Cabinet` take a second argument that can contain more specific settings.
Passing an object to this argument will overwrite the defaults on a per-property basis.
This is done using a shallow merge.

[horizontal]
`states`:: *Default:* `['closed', 'open']`
+
An array of strings.
These are the states that appear in `data-state`.
`cycle()` will move through them in order, one at a time, looping to the beginning once last row is reached.
The strings themselves are essentially arbitrary.
`initState`:: *Default:* `undefined` (effectively `states[0]`)
+
The initial state.
Must be a string from `states`.
If nothing is defined here, then the first state in `states` will be used.
+
Can be overridden by adding `data-state="state-name"` to the Drawer HTML.
`hiddenStates`:: *Default:* `['closed']`
+
An array of strings.
When the Drawer is in a state listed here, it will be considered hidden and the `hidden` HTML attribute will be applied.
If you don't ever want the drawer to be hidden, just set this to an empty array.
`actions`:: *Default:* `[]`
+
An array of callbacks, called when the Drawer observes its state changing.
See link:#api[`addAction()`] for details on how to define actions.
`uuid`:: *Default:* `undefined`
+
Drawer uses a simple internal function generate uuids.
If you require something more crytographically secure, add a callback here that returns a uuid.
`knobs`:: *Default:* `[]`
+
An array of elements or selectors that will be attached to this Drawer.
+
Can be overridden by adding `data-knob="selector"` to the Drawer HTML.
`knobsCycle`:: *Default:* `true`
+
A boolean that determines whether or not clicking on a Knob will fire `cycle()` on its attached Drawers.
`knobActions`:: *Default:* `[]`
+
An array of callbacks, called when a Knob observes a state change on an attached Drawer.
Callbacks receive arguments that are the mutation list, Knob DOM element, and Knob observer.
`knobAccessibility`:: *Default:* `true`
+
This enables (or disables) accessibility features.
Generally you should not turn it off, but for some use cases
(i.e. non-interactive knobs)
it may be desirable to disable it, which you can do by passing `false`.

[#instantiation]
== Instantiation

- `new Drawer(element, settings)` - The `element` argument is *required* and _must_ be a reference to a DOM element, i.e. the result of `document.querySelector()`.
Use this if you want to instantiate only a single, specific Drawer
(i.e. a site navigation menu).
+
This returns an API object (see below) for the Drawer.
- `new Cabinet(selector, settings)` - The `selector` must be either a valid selector
(i.e. something `document.querySelectorAll()` understands)
or a reference to a DOM element.
If no `selector` is specified
(or if `selector` is `undefined`)
`Cabinet` will use the default selector, which is `[data-module="drawer"]`.
+
Use this if you want to instantiate a bunch of Drawers at once with the same settings
(i.e. an accordion).
+
This returns an array of API objects (see below).
+
[NOTE]
====
Passing `undefined` to the first parameter of `Cabinet` will allow you to specify a settings object while still using the default selector.
====

[#api]
== API

Each Drawer has an API object that contains settings information as well as several methods for interacting with that Drawer.

These API objects are returned by link:#instantiation[`new Drawer()` and `new Cabinet()`], and can also be found attached to the Drawer element, under the `drawer` property.

[horizontal]
`settings`:: Contains information describing Drawer behavior.
See link:#config[Config] for full settings documentation.
`getState()`:: Returns the current state of the Drawer.
`setState(state)`:: Sets the state of the Drawer.
`setHidden(hide)`:: Sets the `hidden` attribute of the Drawer element.
`addKnob(knob)`:: Adds a link:#knobs[Knob].
`cycle(states)`:: Advances the Drawer through states.
If the `states` argument is undefined/not passed, then it will move to the next state defined in settings.
If the `states` argument is an array of valid states
(that is, states that also appear in the settings)
then it will move to the next valid state in that array.
See the link:src/drawer.ts[function definition] for more information.
`addAction(action)`:: Add a callback that will be called when the Drawer detects a state change.
The callback recieves the following arguments:
** `list` - An array of mutations detected.
** `el` - The DOM element of the Drawer.
** `observer` - The observer that is watching this drawer.

[#knobs]
== Knobs

Knobs are elements that become attached to a Drawer:
More specifically, they observe the Drawer with MutationObserver in the same way it observes itself, and fire their own actions when they detect mutations.
By default, when clicked Knobs will cycle a Drawer through its states.

Your Drawers aren't required to have Knobs, but they are a quick and easy way to implement the functionality 80% of Drawers are deployed for.

You can attach a Knob to a Drawer in one of three ways:

. Provide an element or selector in the settings at instantiation:
+
[source,javascript]
----
new Drawer(`.drawer`, {knobs: [`.knob`]})
----

. Use `addKnob` to add a Knob to an already instantiated Drawer:
+
[source,javascript]
----
(new Drawer(`.drawer`)).addKnob(`.knob`);

// or

const {addKnob} = document.querySelector(`drawer`).drawer;
addKnob(`.knob`);
----

. Provide a selector in the `data-knob` attribute:
+
[source,html]
----
<div class="drawer" data-knob=".knob"> ... </div>
----

[IMPORTANT]
====
A Drawer can have multiple Knobs, and methods 1 and 3 above can result in attaching multiple Knobs if the provided selectors match more than on element in the DOM.
====

The following is a simple, complete example that will result in a drawer that can be opened and closed by clicking on the button:

[source,javascript]
----
import {Drawer} from "murmur-drawer";

new Drawer(document.querySelector(`.drawer`));
----

[source,html]
----
<div class="drawer"
    data-knob="button[data-controls='drawer']"> üß¶üß¶üß¶üß¶üß¶üß¶üß¶üß¶ </div>
<button data-controls="drawer"> Toggle </button>
----

[#actions]
== Actions

Actions are an important part of how we interact with drawers and knobs.
In both cases, actions have an essentially identical signature:

. `list`
+
This is an array of link:https://developer.mozilla.org/en-US/docs/Web/API/MutationRecord[MutationRecords], each of which describes an observed mutation change.
For most actions, you will be primarily concerned with these items, because they tell you what has just happened.
. `el`
+
The element that this action is attached to:
A Knob or a Drawer.
Notably this is *not* the element that is being observed;
if you want that element it can be found in `MutationRecord.target`.
This element is made available in the event that you want it to react to the mutation.
. `observer`
+
The observer that observed this mutation.
In most cases you won't need this, but it some situations it may be useful,
i.e. if you want to respond to a particular mutation by ceasing to observe.

The MutationObservers here are limited:
Both watch only for changes to the `data-state` and `hidden` attributes on drawers, and only on the element itself
(children are ignored).
However, sometimes both will trigger at the same time, i.e. if the Drawer moves into a hidden state.
`MutationRecord.attributeName` will tell you which particular attribute generated a particular MutationRecord.
`MutationRecord.oldValue` will tell you what the attribute mutated _from_.
The MutationRecord itself doesn't contain the current value, but you can easily get it from `MutationRecord.target`:

[source,javascript]
----
function someAction(list) {
    list.map(record => {
        console.log(record.target.getAttribute(record.attributeName));
    })
}
----

[NOTE]
====
If `settings.initState` differs from the state set on the Drawer at instantiation, the Drawer will fire an action as the states are brought into alignment.
If the Drawer had no state before instantiation
(i.e. it had no `data-state` attribute)
then `MutationRecord.oldValue` will be `undefined`.
This can be a good way to know when an action is being run for the first time, although there is no guarantee this is the case.
====

== Further Reading
Drawer is several dozen lines of code that manage, essentially, one thing:

[source,html]
----
data-state="open"
----

This is the single source of truth for everything Drawer does, and by taking advantage of a number of native browser features it does so efficiently and extensibly.

Using link:https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver[MutationObserver], Drawer watches for state changes and reacts to them.
You are of course encouraged to use Drawer's simple API to interact with its state, but the beauty of MutationObserver is that it doesn't matter:

[source,javascript]
----
const el = document.querySelector(`.drawer`);

// Drawer API
const {setState} = el.drawer;
setState(`closed`);

// Direct access
drawer.dataset.state = `closed`;
----


== Goals

=== Better IE11 Compatibility

Trying to get v1 of this module to work with IE11 was possible, but a huge hassle.
By avoiding any framework, and keeping the source simple, my intent is to make v2 either compatible out of the box, or compatible with a minimal amount of work.
This might look like distributing a separate transpiled source file for browsers that don't support modern technologies, or a sort section in the Readme detailing how to get it working in IE11.

Whatever the case, you should be able to trust that this module will work, easily, in IE11.

=== Simpler

Instead of getting fancy with things like web components, this keeps it simple:
No frameworks or dependencies, just good old link:http://vanilla-js.com/[Vanilla JS].
